#!/usr/bin/env python3

import subprocess
import os
import sys
import argparse
from pathlib import Path

def run_command(command, check=True):
    """Runs a command."""
    try:
        subprocess.run(
            command,
            check=check,
            capture_output=True,
            text=True,
        )
    except FileNotFoundError:
        print(f"Error: Command '{command[0]}' not found.", file=sys.stderr)
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"Error: Command '{' '.join(command)}' failed with error: {e.stderr}", file=sys.stderr)
        sys.exit(1)

def cleanup_session():
    """Cleans up the current worktree and tmux session."""
    if 'TMUX' not in os.environ:
        print("Error: Must be run inside a tmux session.", file=sys.stderr)
        sys.exit(1)

    # Check for uncommitted changes (only if in a git repo)
    try:
        subprocess.run(['git', 'rev-parse', '--is-inside-work-tree'], check=True, capture_output=True)
        in_git = True
    except subprocess.CalledProcessError:
        in_git = False

    if in_git:
        status_result = subprocess.run(['git', 'status', '--porcelain'], capture_output=True, text=True, check=True)
        if status_result.stdout.strip():
            print("Error: Uncommitted changes or untracked files present. Please commit or stash them first.", file=sys.stderr)
            sys.exit(1)
        
        # Get worktree path
        worktree_path = Path(subprocess.run(['git', 'rev-parse', '--show-toplevel'], capture_output=True, text=True, check=True).stdout.strip())
    else:
        worktree_path = None

    # Get current session name
    session_name = subprocess.run(['tmux', 'display-message', '-p', '#S'], capture_output=True, text=True, check=True).stdout.strip()

    # Determine if we should remove the worktree
    should_remove_worktree = False
    if worktree_path:
        home_worktrees = Path.home() / "worktrees"
        try:
            # Check if the worktree path is a subdirectory of ~/worktrees
            worktree_path.relative_to(home_worktrees)
            should_remove_worktree = True
        except ValueError:
            should_remove_worktree = False

    if should_remove_worktree:
        print(f"Cleaning up session '{session_name}' and worktree '{worktree_path}'...")
        cleanup_cmd = f"git worktree remove '{worktree_path}' && tmux kill-session -t '{session_name}'"
    else:
        print(f"Cleaning up session '{session_name}'...")
        cleanup_cmd = f"tmux kill-session -t '{session_name}'"

    # Switch client first
    # Try switching to last session, otherwise detach
    ret = subprocess.run(['tmux', 'switch-client', '-l'], capture_output=True)
    if ret.returncode != 0:
        subprocess.run(['tmux', 'detach-client'], capture_output=True)
    
    # Queue the cleanup
    subprocess.run(['tmux', 'run-shell', '-b', cleanup_cmd], check=True)

def main():
    """Main function to create worktree and tmux session."""
    parser = argparse.ArgumentParser(description="Manage git worktrees and tmux sessions.")
    parser.add_argument("name", nargs="?", help="Branch name or session name")
    parser.add_argument("--done", "-d", action="store_true", help="Clean up current session")
    parser.add_argument("--no-worktree", "-n", action="store_true", help="Create session without worktree")
    
    args = parser.parse_args()

    if args.done:
        cleanup_session()
        return

    if not args.name and not args.no_worktree:
        parser.print_help()
        sys.exit(1)

    branch_name = args.name

    # Check if we are in a git repository
    try:
        subprocess.run(['git', 'rev-parse', '--is-inside-work-tree'], check=True, capture_output=True)
        in_git = True
    except (subprocess.CalledProcessError, FileNotFoundError):
        in_git = False

    target_dir = None
    session_name = None

    if in_git:
        # Get repository name
        repo_toplevel_result = subprocess.run(['git', 'rev-parse', '--show-toplevel'], capture_output=True, text=True, check=True)
        repo_toplevel = repo_toplevel_result.stdout.strip()
        repo_name = os.path.basename(repo_toplevel)

        if not branch_name:
            branch_name = subprocess.run(['git', 'rev-parse', '--abbrev-ref', 'HEAD'], capture_output=True, text=True, check=True).stdout.strip()

        session_name = f"{repo_name}-{branch_name}"

        if args.no_worktree:
            target_dir = Path(repo_toplevel)
            print(f"Using existing repository at {target_dir}")
        else:
            # Define paths and names
            home_dir = Path.home()
            worktree_path = home_dir / "worktrees" / repo_name / branch_name
            target_dir = worktree_path

            # Create worktree if it doesn't exist
            if worktree_path.exists():
                print(f"Worktree already exists at {worktree_path}")
            else:
                print(f"Creating worktree for branch '{branch_name}' at {worktree_path}...")
                worktree_path.parent.mkdir(parents=True, exist_ok=True)
                
                branch_exists_result = subprocess.run(['git', 'show-ref', '--verify', '--quiet', f'refs/heads/{branch_name}'])
                if branch_exists_result.returncode != 0:
                    try:
                        # Use a simpler prompt or allow handling from args in future
                        # For now, sticking to input() but being mindful it might hang in tests if not mocked
                        # In tests, we should ensure branches exist before calling this if possible,
                        # or mock input.
                        create_branch = input(f"Branch '{branch_name}' does not exist. Create it? (y/n) ")
                        if create_branch.lower() == 'y':
                            run_command(['git', 'branch', branch_name])
                        else:
                            print("Aborting.")
                            sys.exit(0)
                    except (EOFError, KeyboardInterrupt):
                        print("\nAborting.")
                        sys.exit(0)

                run_command(['git', 'worktree', 'add', str(worktree_path), branch_name])
    else:
        # Not in a git repo
        if not branch_name:
            branch_name = os.path.basename(os.getcwd())
        session_name = branch_name
        target_dir = Path.cwd()
        print(f"Not in a git repository. Using current directory {target_dir}")

    # Check if tmux session exists
    session_exists_result = subprocess.run(['tmux', 'has-session', '-t', f'={session_name}'], capture_output=True)

    if session_exists_result.returncode == 0:
        print(f"Session '{session_name}' already exists.")
    else:
        print(f"Creating new tmux session '{session_name}'...")
        run_command(['tmux', 'new-session', '-d', '-s', session_name, '-c', str(target_dir)])

    # If inside tmux, switch to the new session, otherwise attach
    if 'TMUX' in os.environ:
        print(f"Switching to session '{session_name}'...")
        # Use execvp to replace the current process with tmux
        os.execvp('tmux', ['tmux', 'switch-client', '-t', session_name])
    else:
        print(f"Attaching to session '{session_name}'...")
        os.execvp('tmux', ['tmux', 'attach-session', '-t', session_name])

if __name__ == "__main__":
    main()
